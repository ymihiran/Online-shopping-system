{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _fs = _interopRequireDefault(require(\"fs\"));\n\nvar _JwtGenerator = _interopRequireDefault(require(\"./JwtGenerator\"));\n\nvar _HashGenerator = _interopRequireDefault(require(\"./HashGenerator\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Right now only key/secret credentials are supported.\n * However, in time JWT will also be supported.\n * The `Credentials` object provides an abstraction to this.\n *\n * @param {string} apiKey - A Vonage API Key\n * @param {string} apiSecret - A Vonage API Secret\n * @param {string} [applicationId] - A VonageApplication ID\n * @param {string|Buffer} [privateKey] -  When a string value is passed it should\n *                        either represent the path to the private key, or the actual\n *                        private key in string format. If a Buffer is passed then\n *                        it should be the key read from the file system.\n * @param {string} [signatureSecret] - A Vonage signature Secret\n * @param {string} [signatureMethod] - A Vonage compatible request signing method\n */\n\n\nclass Credentials {\n  constructor(apiKey, apiSecret, privateKey, applicationId, signatureSecret, signatureMethod) {\n    this.apiKey = apiKey;\n    this.apiSecret = apiSecret;\n    this.privateKey = null;\n    this.applicationId = applicationId;\n    this.signatureSecret = signatureSecret;\n    this.signatureMethod = signatureMethod;\n\n    if (privateKey instanceof Buffer) {\n      // it is already a buffer, use it as-is\n      this.privateKey = privateKey;\n    } else if (typeof privateKey === \"string\" && privateKey.startsWith(\"-----BEGIN PRIVATE KEY-----\")) {\n      // It's a key string. Check for \\n, replace with newlines\n      privateKey = privateKey.replace(/\\\\n/g, \"\\n\");\n      this.privateKey = Buffer.from(privateKey, \"utf-8\");\n    } else if (privateKey !== undefined) {\n      if (!_fs.default.existsSync(privateKey)) {\n        throw new Error(\"File \\\"\".concat(privateKey, \"\\\" not found.\"));\n      }\n\n      this.privateKey = _fs.default.readFileSync(privateKey);\n    }\n    /** @private */\n\n\n    this._jwtGenerator = new _JwtGenerator.default();\n    this._hashGenerator = new _HashGenerator.default();\n  }\n  /**\n   * Generate a Jwt using the Private Key in the Credentials.\n   * By default the credentials.applicationId will be used when creating the token.\n   * However, this can be overwritten.\n   *\n   * @param {string} [applicationId] an application ID to be used instead of the\n   *                default Credentials.applicationId value.\n   *\n   * @returns {string} The generated JWT\n   */\n\n\n  generateJwt() {\n    var applicationId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.applicationId;\n    var privateKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.privateKey;\n    var claims = {\n      application_id: applicationId\n    };\n\n    var token = this._jwtGenerator.generate(privateKey, claims);\n\n    return token;\n  }\n\n  generateSignature(params) {\n    var signatureSecret = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.signatureSecret;\n    var signatureMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.signatureMethod;\n    return this._hashGenerator.generate(signatureMethod, signatureSecret, params);\n  }\n  /**\n   * @private\n   * Used for testing purposes only.\n   */\n\n\n  _setJwtGenerator(generator) {\n    this._jwtGenerator = generator;\n  }\n  /**\n   * @private\n   * Used for testing purposes only.\n   */\n\n\n  _setHashGenerator(generator) {\n    this._hashGenerator = generator;\n  }\n  /**\n   * Ensures a credentials instance is used.\n   *\n   * Key/Secret credentials are only supported at present.\n   */\n\n\n  static parse(obj) {\n    if (obj instanceof Credentials) {\n      return obj;\n    } else {\n      return new Credentials(obj.apiKey, obj.apiSecret, obj.privateKey, obj.applicationId, obj.signatureSecret, obj.signatureMethod);\n    }\n  }\n\n}\n\nvar _default = Credentials;\nexports.default = _default;\nmodule.exports = exports.default;","map":{"version":3,"sources":["../src/Credentials.js"],"names":["constructor","privateKey","Buffer","fs","JwtGenerator","HashGenerator","generateJwt","applicationId","claims","application_id","token","generateSignature","signatureSecret","signatureMethod","_setJwtGenerator","_setHashGenerator","parse","obj","Credentials"],"mappings":"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","sourcesContent":["\"use strict\";\n\nimport fs from \"fs\";\nimport JwtGenerator from \"./JwtGenerator\";\nimport HashGenerator from \"./HashGenerator\";\n\n/**\n * Right now only key/secret credentials are supported.\n * However, in time JWT will also be supported.\n * The `Credentials` object provides an abstraction to this.\n *\n * @param {string} apiKey - A Vonage API Key\n * @param {string} apiSecret - A Vonage API Secret\n * @param {string} [applicationId] - A VonageApplication ID\n * @param {string|Buffer} [privateKey] -  When a string value is passed it should\n *                        either represent the path to the private key, or the actual\n *                        private key in string format. If a Buffer is passed then\n *                        it should be the key read from the file system.\n * @param {string} [signatureSecret] - A Vonage signature Secret\n * @param {string} [signatureMethod] - A Vonage compatible request signing method\n */\nclass Credentials {\n  constructor(\n    apiKey,\n    apiSecret,\n    privateKey,\n    applicationId,\n    signatureSecret,\n    signatureMethod\n  ) {\n    this.apiKey = apiKey;\n    this.apiSecret = apiSecret;\n\n    this.privateKey = null;\n    this.applicationId = applicationId;\n\n    this.signatureSecret = signatureSecret;\n    this.signatureMethod = signatureMethod;\n\n    if (privateKey instanceof Buffer) {\n      // it is already a buffer, use it as-is\n      this.privateKey = privateKey;\n    } else if (\n      typeof privateKey === \"string\" &&\n      privateKey.startsWith(\"-----BEGIN PRIVATE KEY-----\")\n    ) {\n      // It's a key string. Check for \\n, replace with newlines\n      privateKey = privateKey.replace(/\\\\n/g, \"\\n\");\n      this.privateKey = Buffer.from(privateKey, \"utf-8\");\n    } else if (privateKey !== undefined) {\n      if (!fs.existsSync(privateKey)) {\n        throw new Error(`File \"${privateKey}\" not found.`);\n      }\n      this.privateKey = fs.readFileSync(privateKey);\n    }\n\n    /** @private */\n    this._jwtGenerator = new JwtGenerator();\n    this._hashGenerator = new HashGenerator();\n  }\n\n  /**\n   * Generate a Jwt using the Private Key in the Credentials.\n   * By default the credentials.applicationId will be used when creating the token.\n   * However, this can be overwritten.\n   *\n   * @param {string} [applicationId] an application ID to be used instead of the\n   *                default Credentials.applicationId value.\n   *\n   * @returns {string} The generated JWT\n   */\n  generateJwt(\n    applicationId = this.applicationId,\n    privateKey = this.privateKey\n  ) {\n    var claims = {\n      application_id: applicationId,\n    };\n    var token = this._jwtGenerator.generate(privateKey, claims);\n    return token;\n  }\n\n  generateSignature(\n    params,\n    signatureSecret = this.signatureSecret,\n    signatureMethod = this.signatureMethod\n  ) {\n    return this._hashGenerator.generate(\n      signatureMethod,\n      signatureSecret,\n      params\n    );\n  }\n\n  /**\n   * @private\n   * Used for testing purposes only.\n   */\n  _setJwtGenerator(generator) {\n    this._jwtGenerator = generator;\n  }\n\n  /**\n   * @private\n   * Used for testing purposes only.\n   */\n  _setHashGenerator(generator) {\n    this._hashGenerator = generator;\n  }\n\n  /**\n   * Ensures a credentials instance is used.\n   *\n   * Key/Secret credentials are only supported at present.\n   */\n  static parse(obj) {\n    if (obj instanceof Credentials) {\n      return obj;\n    } else {\n      return new Credentials(\n        obj.apiKey,\n        obj.apiSecret,\n        obj.privateKey,\n        obj.applicationId,\n        obj.signatureSecret,\n        obj.signatureMethod\n      );\n    }\n  }\n}\n\nexport default Credentials;\n"]},"metadata":{},"sourceType":"script"}