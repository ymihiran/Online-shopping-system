{"ast":null,"code":"\"use strict\";\n\nvar _uuid = require(\"uuid\");\n\nvar _jsonwebtoken = _interopRequireDefault(require(\"jsonwebtoken\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nclass JwtGenerator {\n  /**\n   * Generate a JSON Web Token (JWT).\n   *\n   * @param {Buffer} cert - the private key certificate to be used when signing\n   * the claims.\n   * @param {Object} claims - additional claims to include within the generated\n   * JWT.\n   *\n   * @returns {String} the generated token\n   */\n  generate(cert) {\n    var claims = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!(cert instanceof Buffer)) {\n      throw new Error(\"cert must be of type Buffer\");\n    }\n\n    if (typeof claims !== \"object\") {\n      throw new Error(\"claims must be of type object\");\n    }\n\n    var toSign = {\n      iat: claims.issuedAt || parseInt(Date.now() / 1000, 10),\n      jti: claims.jti || (0, _uuid.v1)()\n    };\n    Object.keys(claims).forEach(key => {\n      toSign[key] = claims[key];\n    });\n\n    var token = _jsonwebtoken.default.sign(toSign, cert, {\n      algorithm: \"RS256\"\n    });\n\n    return token;\n  }\n\n}\n\nmodule.exports = JwtGenerator;","map":{"version":3,"sources":["../src/JwtGenerator.js"],"names":["generate","claims","cert","toSign","iat","parseInt","Date","jti","Object","key","token","algorithm","module"],"mappings":";;AAAA,IAAA,KAAA,GAAA,OAAA,CAAA,MAAA,CAAA;;AACA,IAAA,aAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,cAAA,CAAA,CAAA;;;;;;;;AAEA,MAAA,YAAA,CAAmB;AACjB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEA,EAAAA,QAAQ,CAAA,IAAA,EAAoB;AAAA,QAAbC,MAAa,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,EAAI;;AAC1B,QAAI,EAAEC,IAAI,YAAV,MAAI,CAAJ,EAA+B;AAC7B,YAAM,IAAA,KAAA,CAAN,6BAAM,CAAN;AACD;;AACD,QAAI,OAAA,MAAA,KAAJ,QAAA,EAAgC;AAC9B,YAAM,IAAA,KAAA,CAAN,+BAAM,CAAN;AACD;;AAED,QAAIC,MAAM,GAAG;AACXC,MAAAA,GAAG,EAAEH,MAAM,CAANA,QAAAA,IAAmBI,QAAQ,CAACC,IAAI,CAAJA,GAAAA,KAAD,IAAA,EADrB,EACqB,CADrB;AAEXC,MAAAA,GAAG,EAAEN,MAAM,CAANA,GAAAA,IAAc,CAAA,GAAA,KAAA,CAAA,EAAA;AAFR,KAAb;AAIAO,IAAAA,MAAM,CAANA,IAAAA,CAAAA,MAAAA,EAAAA,OAAAA,CAA6BC,GAAD,IAAS;AACnCN,MAAAA,MAAM,CAANA,GAAM,CAANA,GAAcF,MAAM,CAApBE,GAAoB,CAApBA;AADFK,KAAAA;;AAIA,QAAIE,KAAK,GAAG,aAAA,CAAA,OAAA,CAAA,IAAA,CAAA,MAAA,EAAA,IAAA,EAAuB;AAAEC,MAAAA,SAAS,EAAE;AAAb,KAAvB,CAAZ;;AACA,WAAA,KAAA;AACD;;AA7BgB;;AAgCnBC,MAAM,CAANA,OAAAA,GAAAA,YAAAA","sourcesContent":["import { v1 as uuidv1 } from \"uuid\";\nimport jwt from \"jsonwebtoken\";\n\nclass JwtGenerator {\n  /**\n   * Generate a JSON Web Token (JWT).\n   *\n   * @param {Buffer} cert - the private key certificate to be used when signing\n   * the claims.\n   * @param {Object} claims - additional claims to include within the generated\n   * JWT.\n   *\n   * @returns {String} the generated token\n   */\n  generate(cert, claims = {}) {\n    if (!(cert instanceof Buffer)) {\n      throw new Error(\"cert must be of type Buffer\");\n    }\n    if (typeof claims !== \"object\") {\n      throw new Error(\"claims must be of type object\");\n    }\n\n    var toSign = {\n      iat: claims.issuedAt || parseInt(Date.now() / 1000, 10),\n      jti: claims.jti || uuidv1(),\n    };\n    Object.keys(claims).forEach((key) => {\n      toSign[key] = claims[key];\n    });\n\n    var token = jwt.sign(toSign, cert, { algorithm: \"RS256\" });\n    return token;\n  }\n}\n\nmodule.exports = JwtGenerator;\n"]},"metadata":{},"sourceType":"script"}