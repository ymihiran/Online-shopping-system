{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar https = require(\"https\");\n\nvar http = require(\"http\");\n\nvar request = require(\"request\");\n\nvar querystring = require(\"query-string\");\n\nvar URL = require(\"url\").URL;\n\nvar isValidUrl = s => {\n  if (!s || s === null) return false;\n\n  try {\n    if (s === \"api.nexmo.com\") return s;\n    var o = new URL(s);\n    return o.host;\n  } catch (err) {\n    return false;\n  }\n};\n\nclass HttpClient {\n  constructor(options, credentials) {\n    var hostOverride = isValidUrl(options.host);\n    this.credentials = credentials;\n    this.host = hostOverride ? hostOverride : \"rest.nexmo.com\";\n    this.port = options.port || 443;\n    this.https = options.https || https;\n    this.http = options.http || http;\n    this.headers = {\n      \"Content-Type\": \"application/x-www-form-urlencoded\",\n      Accept: \"application/json\"\n    };\n    this.logger = options.logger;\n    this.timeout = options.timeout;\n    this.requestLib = request;\n\n    if (options.userAgent) {\n      this.headers[\"User-Agent\"] = options.userAgent;\n    }\n  }\n\n  request(endpoint, method, callback) {\n    var skipJsonParsing = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var customResponseParser = arguments.length > 4 ? arguments[4] : undefined;\n\n    if (typeof method === \"function\") {\n      callback = method;\n      endpoint.method = endpoint.method || \"GET\";\n    } else if (typeof method !== \"undefined\") {\n      endpoint.method = method;\n    }\n\n    var options = {\n      host: endpoint.host ? endpoint.host : this.host,\n      port: this.port,\n      path: endpoint.path,\n      method: endpoint.method,\n      headers: Object.assign({}, this.headers, endpoint.headers)\n    };\n\n    if (this.timeout !== undefined) {\n      options.timeout = this.timeout;\n    } // Allow existing headers to be overridden\n    // Allow new headers to be added\n\n\n    if (endpoint.headers) {\n      Object.keys(endpoint.headers).forEach(function (key) {\n        options.headers[key] = endpoint.headers[key];\n      });\n    } // the output here can returnn one of two options:\n    // - Using `sig` & `timestamp` in the JSON body\n    // - Using `sig` & `timestamp` in the query string\n\n\n    if (this.credentials.signatureSecret && this.credentials.signatureMethod) {\n      // you must first add a timestamp\n      var params;\n      var splitPath;\n      var path; // determine if the response should be querystring or JSON body\n\n      if (!endpoint.body) {\n        // this branch is for query string\n        splitPath = options.path.split(/\\?(.+)/);\n        path = splitPath[0];\n        params = querystring.parse(splitPath[1]);\n      } else {\n        // this section is for JSON body\n        params = JSON.parse(endpoint.body);\n      } // add timestamp if not already present\n\n\n      if (!params.timestamp) {\n        params.timestamp = (new Date().getTime() / 1000 | 0).toString();\n      } // strip API Secret\n\n\n      delete params.api_secret;\n      var hash = this.credentials.generateSignature(params);\n      params.sig = hash;\n\n      if (!endpoint.body) {\n        //this section is for querystring\n        var query = \"\"; // rebuild query\n\n        Object.keys(params).sort().forEach(key => {\n          query += \"&\" + key + \"=\" + encodeURI(params[key]);\n        }); // replace the first & with ?\n\n        query = query.replace(/&/i, \"?\");\n        options.path = \"\".concat(path).concat(query);\n      } else {\n        endpoint.body = JSON.stringify(params);\n      }\n    }\n\n    this.logger.info(\"Request:\", options, \"\\nBody:\", endpoint.body);\n    var request;\n\n    if (options.port === 443) {\n      request = this.https.request(options);\n    } else {\n      request = this.http.request(options);\n    }\n\n    request.end(endpoint.body); // Keep an array of String or Buffers,\n    // depending on content type (binary or JSON) of response\n\n    var responseData = [];\n    request.on(\"response\", response => {\n      var isBinary = response.headers[\"content-type\"] === \"application/octet-stream\";\n\n      if (!isBinary) {\n        response.setEncoding(\"utf8\");\n      }\n\n      response.on(\"data\", chunk => {\n        responseData.push(chunk);\n      });\n      response.on(\"end\", () => {\n        this.logger.info(\"response ended:\", response.statusCode);\n\n        if (callback) {\n          if (isBinary) {\n            responseData = Buffer.concat(responseData);\n          }\n\n          this.__parseResponse(response, responseData, endpoint.method, callback, skipJsonParsing, customResponseParser);\n        }\n      });\n      response.on(\"close\", e => {\n        if (e) {\n          this.logger.error(\"problem with API request detailed stacktrace below \");\n          this.logger.error(e);\n          callback(e);\n        }\n      });\n    });\n    request.on(\"error\", e => {\n      this.logger.error(\"problem with API request detailed stacktrace below \");\n      this.logger.error(e);\n      callback(e);\n    });\n  }\n\n  __parseResponse(httpResponse, data, method, callback, skipJsonParsing, customResponseParser) {\n    var isArrayOrBuffer = data instanceof Array || data instanceof Buffer;\n\n    if (!isArrayOrBuffer) {\n      throw new Error(\"data should be of type Array or Buffer\");\n    }\n\n    var status = httpResponse.statusCode;\n    var headers = httpResponse.headers;\n    var response = null;\n    var error = null;\n\n    try {\n      if (status >= 500) {\n        error = {\n          message: \"Server Error\",\n          statusCode: status\n        };\n      } else if (httpResponse.headers[\"content-type\"] === \"application/octet-stream\") {\n        response = data;\n      } else if (status === 429) {\n        // 429 does not return a parsable body\n        if (!headers[\"retry-after\"]) {\n          // retry based on allowed per second\n          var retryAfterMillis = method === \"POST\" ? 1000 / 2 : 1000 / 5;\n          headers[\"retry-after\"] = retryAfterMillis;\n        }\n\n        error = {\n          body: data.join(\"\")\n        };\n      } else if (status === 204) {\n        response = null;\n      } else if (status >= 400 || status < 200) {\n        error = {\n          body: JSON.parse(data.join(\"\")),\n          headers\n        };\n      } else if (method !== \"DELETE\") {\n        if (!!skipJsonParsing) {\n          response = data.join(\"\");\n        } else {\n          response = JSON.parse(data.join(\"\"));\n        }\n      } else {\n        response = data;\n      }\n    } catch (parseError) {\n      this.logger.error(parseError);\n      this.logger.error(\"could not convert API response to JSON, above error is ignored and raw API response is returned to client\");\n      this.logger.error(\"Raw Error message from API \");\n      this.logger.error(\"\\\"\".concat(data, \"\\\"\"));\n      error = {\n        status: status,\n        message: \"The API response could not be parsed.\",\n        body: data.join(\"\"),\n        parseError: parseError\n      };\n    }\n\n    if (error) {\n      error.statusCode = status;\n      error.headers = headers;\n    }\n\n    if (typeof callback === \"function\") {\n      if (typeof customResponseParser === \"function\") {\n        // don't try to parse the response on errors\n        if (response) {\n          response = customResponseParser(response);\n        }\n      }\n\n      callback(error, response);\n    }\n  }\n\n  _addLimitedAccessMessageToErrors(callback, limitedAccessStatus) {\n    return function (err, data) {\n      if (err && err.status == limitedAccessStatus) {\n        err._INFO_ = \"This endpoint may need activating on your account. Please email support@nexmo.com for more information\";\n      }\n\n      return callback(err, data);\n    };\n  }\n\n  get(path, params, callback) {\n    var useJwt = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var useBasicAuth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n    if (!callback) {\n      if (typeof params == \"function\") {\n        callback = params;\n        params = {};\n      }\n    }\n\n    params = params || {};\n\n    if (!useJwt && !useBasicAuth) {\n      params[\"api_key\"] = this.credentials.apiKey;\n      params[\"api_secret\"] = this.credentials.apiSecret;\n    }\n\n    path = path + \"?\" + querystring.stringify(params);\n    var headers = {\n      \"Content-Type\": \"application/json\"\n    };\n\n    if (useJwt) {\n      headers[\"Authorization\"] = \"Bearer \".concat(this.credentials.generateJwt());\n    }\n\n    if (useBasicAuth) {\n      headers[\"Authorization\"] = \"Basic \".concat(Buffer.from(this.credentials.apiKey + \":\" + this.credentials.apiSecret).toString(\"base64\"));\n    }\n\n    this.request({\n      path: path,\n      headers\n    }, \"GET\", callback);\n  }\n\n  delete(path, callback, useJwt, useBasicAuth) {\n    var params = {};\n\n    if (!useJwt && !useBasicAuth) {\n      params[\"api_key\"] = this.credentials.apiKey;\n      params[\"api_secret\"] = this.credentials.apiSecret;\n    }\n\n    var headers = {};\n\n    if (useBasicAuth) {\n      headers[\"Authorization\"] = \"Basic \".concat(Buffer.from(this.credentials.apiKey + \":\" + this.credentials.apiSecret).toString(\"base64\"));\n    }\n\n    path = path + \"?\" + querystring.stringify(params);\n    this.request({\n      path: path,\n      headers\n    }, \"DELETE\", callback);\n  }\n\n  postFile(path, options, callback, useJwt) {\n    var qs = {};\n\n    if (!useJwt) {\n      qs[\"api_key\"] = this.credentials.apiKey;\n      qs[\"api_secret\"] = this.credentials.apiSecret;\n    }\n\n    if (Object.keys(qs).length) {\n      var joinChar = \"?\";\n\n      if (path.indexOf(joinChar) !== -1) {\n        joinChar = \"&\";\n      }\n\n      path = path + joinChar + querystring.stringify(qs);\n    }\n\n    var file = options.file;\n    delete options.file; // We don't send this as metadata\n\n    var formData = {};\n\n    if (file) {\n      formData[\"filedata\"] = {\n        value: file,\n        options: {\n          filename: options.filename || null\n        }\n      };\n    }\n\n    if (options.info) {\n      formData.info = JSON.stringify(options.info);\n    }\n\n    if (options.url) {\n      formData.url = options.url;\n    }\n\n    var protocol = this.port === 443 ? \"https://\" : \"http://\";\n    this.requestLib.post({\n      url: protocol + this.host + path,\n      formData: formData,\n      headers: {\n        Authorization: \"Bearer \".concat(this.credentials.generateJwt())\n      }\n    }, callback);\n  }\n\n  post(path, params, callback, useJwt) {\n    var qs = {};\n\n    if (!useJwt) {\n      qs[\"api_key\"] = this.credentials.apiKey;\n      qs[\"api_secret\"] = this.credentials.apiSecret;\n    }\n\n    var joinChar = \"?\";\n\n    if (path.indexOf(joinChar) !== -1) {\n      joinChar = \"&\";\n    }\n\n    path = path + joinChar + querystring.stringify(qs);\n    this.request({\n      path: path,\n      body: querystring.stringify(params)\n    }, \"POST\", callback);\n  }\n\n  postJson(path, params, callback, useJwt, useBasicAuth) {\n    var qs = {};\n\n    if (!useJwt && !useBasicAuth) {\n      qs[\"api_key\"] = this.credentials.apiKey;\n      qs[\"api_secret\"] = this.credentials.apiSecret;\n    }\n\n    var joinChar = \"?\";\n\n    if (path.indexOf(joinChar) !== -1) {\n      joinChar = \"&\";\n    }\n\n    path = path + joinChar + querystring.stringify(qs);\n    var headers = {\n      \"Content-Type\": \"application/json\"\n    };\n\n    if (useBasicAuth) {\n      headers[\"Authorization\"] = \"Basic \".concat(Buffer.from(this.credentials.apiKey + \":\" + this.credentials.apiSecret).toString(\"base64\"));\n    }\n\n    this.request({\n      path: path,\n      body: JSON.stringify(params),\n      headers\n    }, \"POST\", callback);\n  }\n\n  postUseQueryString(path, params, callback, useJwt) {\n    params = params || {};\n\n    if (!useJwt) {\n      params[\"api_key\"] = this.credentials.apiKey;\n      params[\"api_secret\"] = this.credentials.apiSecret;\n    }\n\n    path = path + \"?\" + querystring.stringify(params);\n    this.request({\n      path: path\n    }, \"POST\", callback);\n  }\n\n}\n\nvar _default = HttpClient;\nexports.default = _default;\nmodule.exports = exports.default;","map":{"version":3,"sources":["../src/HttpClient.js"],"names":["https","require","http","request","querystring","URL","isValidUrl","s","o","constructor","hostOverride","options","Accept","skipJsonParsing","customResponseParser","callback","endpoint","host","port","path","method","headers","Object","splitPath","params","JSON","hash","query","key","encodeURI","responseData","response","isBinary","chunk","Buffer","e","__parseResponse","isArrayOrBuffer","data","status","httpResponse","error","message","statusCode","retryAfterMillis","body","parseError","_addLimitedAccessMessageToErrors","err","get","useJwt","useBasicAuth","delete","postFile","qs","joinChar","file","formData","value","filename","protocol","url","Authorization","post","postJson","postUseQueryString","HttpClient"],"mappings":"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","sourcesContent":["var https = require(\"https\");\nvar http = require(\"http\");\nvar request = require(\"request\");\nvar querystring = require(\"query-string\");\nvar URL = require(\"url\").URL;\n\nconst isValidUrl = (s) => {\n  if (!s || s === null) return false;\n\n  try {\n    if (s === \"api.nexmo.com\") return s;\n    let o = new URL(s);\n    return o.host;\n  } catch (err) {\n    return false;\n  }\n};\n\nclass HttpClient {\n  constructor(options, credentials) {\n    let hostOverride = isValidUrl(options.host);\n    this.credentials = credentials;\n    this.host = hostOverride ? hostOverride : `rest.nexmo.com`;\n    this.port = options.port || 443;\n    this.https = options.https || https;\n    this.http = options.http || http;\n    this.headers = {\n      \"Content-Type\": \"application/x-www-form-urlencoded\",\n      Accept: \"application/json\",\n    };\n    this.logger = options.logger;\n    this.timeout = options.timeout;\n    this.requestLib = request;\n\n    if (options.userAgent) {\n      this.headers[\"User-Agent\"] = options.userAgent;\n    }\n  }\n\n  request(\n    endpoint,\n    method,\n    callback,\n    skipJsonParsing = false,\n    customResponseParser\n  ) {\n    if (typeof method === \"function\") {\n      callback = method;\n      endpoint.method = endpoint.method || \"GET\";\n    } else if (typeof method !== \"undefined\") {\n      endpoint.method = method;\n    }\n\n    var options = {\n      host: endpoint.host ? endpoint.host : this.host,\n      port: this.port,\n      path: endpoint.path,\n      method: endpoint.method,\n      headers: Object.assign({}, this.headers, endpoint.headers),\n    };\n\n    if (this.timeout !== undefined) {\n      options.timeout = this.timeout;\n    }\n\n    // Allow existing headers to be overridden\n    // Allow new headers to be added\n    if (endpoint.headers) {\n      Object.keys(endpoint.headers).forEach(function (key) {\n        options.headers[key] = endpoint.headers[key];\n      });\n    }\n\n    // the output here can returnn one of two options:\n    // - Using `sig` & `timestamp` in the JSON body\n    // - Using `sig` & `timestamp` in the query string\n\n    if (this.credentials.signatureSecret && this.credentials.signatureMethod) {\n      // you must first add a timestamp\n      let params;\n      let splitPath;\n      let path;\n\n      // determine if the response should be querystring or JSON body\n      if (!endpoint.body) {\n        // this branch is for query string\n        splitPath = options.path.split(/\\?(.+)/);\n        path = splitPath[0];\n\n        params = querystring.parse(splitPath[1]);\n      } else {\n        // this section is for JSON body\n        params = JSON.parse(endpoint.body);\n      }\n\n      // add timestamp if not already present\n      if (!params.timestamp) {\n        params.timestamp = ((new Date().getTime() / 1000) | 0).toString();\n      }\n\n      // strip API Secret\n      delete params.api_secret;\n\n      let hash = this.credentials.generateSignature(params);\n      params.sig = hash;\n\n      if (!endpoint.body) {\n        //this section is for querystring\n        let query = \"\";\n\n        // rebuild query\n        Object.keys(params)\n          .sort()\n          .forEach((key) => {\n            query += \"&\" + key + \"=\" + encodeURI(params[key]);\n          });\n\n        // replace the first & with ?\n        query = query.replace(/&/i, \"?\");\n\n        options.path = `${path}${query}`;\n      } else {\n        endpoint.body = JSON.stringify(params);\n      }\n    }\n\n    this.logger.info(\"Request:\", options, \"\\nBody:\", endpoint.body);\n\n    var request;\n\n    if (options.port === 443) {\n      request = this.https.request(options);\n    } else {\n      request = this.http.request(options);\n    }\n\n    request.end(endpoint.body);\n\n    // Keep an array of String or Buffers,\n    // depending on content type (binary or JSON) of response\n    var responseData = [];\n\n    request.on(\"response\", (response) => {\n      var isBinary =\n        response.headers[\"content-type\"] === \"application/octet-stream\";\n      if (!isBinary) {\n        response.setEncoding(\"utf8\");\n      }\n\n      response.on(\"data\", (chunk) => {\n        responseData.push(chunk);\n      });\n\n      response.on(\"end\", () => {\n        this.logger.info(\"response ended:\", response.statusCode);\n        if (callback) {\n          if (isBinary) {\n            responseData = Buffer.concat(responseData);\n          }\n\n          this.__parseResponse(\n            response,\n            responseData,\n            endpoint.method,\n            callback,\n            skipJsonParsing,\n            customResponseParser\n          );\n        }\n      });\n      response.on(\"close\", (e) => {\n        if (e) {\n          this.logger.error(\n            \"problem with API request detailed stacktrace below \"\n          );\n          this.logger.error(e);\n          callback(e);\n        }\n      });\n    });\n    request.on(\"error\", (e) => {\n      this.logger.error(\"problem with API request detailed stacktrace below \");\n      this.logger.error(e);\n      callback(e);\n    });\n  }\n\n  __parseResponse(\n    httpResponse,\n    data,\n    method,\n    callback,\n    skipJsonParsing,\n    customResponseParser\n  ) {\n    const isArrayOrBuffer = data instanceof Array || data instanceof Buffer;\n    if (!isArrayOrBuffer) {\n      throw new Error(\"data should be of type Array or Buffer\");\n    }\n\n    const status = httpResponse.statusCode;\n    const headers = httpResponse.headers;\n\n    let response = null;\n    var error = null;\n\n    try {\n      if (status >= 500) {\n        error = {\n          message: \"Server Error\",\n          statusCode: status,\n        };\n      } else if (\n        httpResponse.headers[\"content-type\"] === \"application/octet-stream\"\n      ) {\n        response = data;\n      } else if (status === 429) {\n        // 429 does not return a parsable body\n        if (!headers[\"retry-after\"]) {\n          // retry based on allowed per second\n          const retryAfterMillis = method === \"POST\" ? 1000 / 2 : 1000 / 5;\n          headers[\"retry-after\"] = retryAfterMillis;\n        }\n        error = {\n          body: data.join(\"\"),\n        };\n      } else if (status === 204) {\n        response = null;\n      } else if (status >= 400 || status < 200) {\n        error = {\n          body: JSON.parse(data.join(\"\")),\n          headers,\n        };\n      } else if (method !== \"DELETE\") {\n        if (!!skipJsonParsing) {\n          response = data.join(\"\");\n        } else {\n          response = JSON.parse(data.join(\"\"));\n        }\n      } else {\n        response = data;\n      }\n    } catch (parseError) {\n      this.logger.error(parseError);\n      this.logger.error(\n        \"could not convert API response to JSON, above error is ignored and raw API response is returned to client\"\n      );\n      this.logger.error(\"Raw Error message from API \");\n      this.logger.error(`\"${data}\"`);\n\n      error = {\n        status: status,\n        message: \"The API response could not be parsed.\",\n        body: data.join(\"\"),\n        parseError: parseError,\n      };\n    }\n\n    if (error) {\n      error.statusCode = status;\n      error.headers = headers;\n    }\n\n    if (typeof callback === \"function\") {\n      if (typeof customResponseParser === \"function\") {\n        // don't try to parse the response on errors\n        if (response) {\n          response = customResponseParser(response);\n        }\n      }\n      callback(error, response);\n    }\n  }\n\n  _addLimitedAccessMessageToErrors(callback, limitedAccessStatus) {\n    return function (err, data) {\n      if (err && err.status == limitedAccessStatus) {\n        err._INFO_ =\n          \"This endpoint may need activating on your account. Please email support@nexmo.com for more information\";\n      }\n\n      return callback(err, data);\n    };\n  }\n\n  get(path, params, callback, useJwt = false, useBasicAuth = false) {\n    if (!callback) {\n      if (typeof params == \"function\") {\n        callback = params;\n        params = {};\n      }\n    }\n\n    params = params || {};\n    if (!useJwt && !useBasicAuth) {\n      params[\"api_key\"] = this.credentials.apiKey;\n      params[\"api_secret\"] = this.credentials.apiSecret;\n    }\n\n    path = path + \"?\" + querystring.stringify(params);\n\n    const headers = {\n      \"Content-Type\": \"application/json\",\n    };\n    if (useJwt) {\n      headers[\"Authorization\"] = `Bearer ${this.credentials.generateJwt()}`;\n    }\n    if (useBasicAuth) {\n      headers[\"Authorization\"] = `Basic ${Buffer.from(\n        this.credentials.apiKey + \":\" + this.credentials.apiSecret\n      ).toString(\"base64\")}`;\n    }\n\n    this.request(\n      {\n        path: path,\n        headers,\n      },\n      \"GET\",\n      callback\n    );\n  }\n\n  delete(path, callback, useJwt, useBasicAuth) {\n    let params = {};\n    if (!useJwt && !useBasicAuth) {\n      params[\"api_key\"] = this.credentials.apiKey;\n      params[\"api_secret\"] = this.credentials.apiSecret;\n    }\n\n    let headers = {};\n\n    if (useBasicAuth) {\n      headers[\"Authorization\"] = `Basic ${Buffer.from(\n        this.credentials.apiKey + \":\" + this.credentials.apiSecret\n      ).toString(\"base64\")}`;\n    }\n    path = path + \"?\" + querystring.stringify(params);\n\n    this.request(\n      {\n        path: path,\n        headers,\n      },\n      \"DELETE\",\n      callback\n    );\n  }\n\n  postFile(path, options, callback, useJwt) {\n    let qs = {};\n    if (!useJwt) {\n      qs[\"api_key\"] = this.credentials.apiKey;\n      qs[\"api_secret\"] = this.credentials.apiSecret;\n    }\n\n    if (Object.keys(qs).length) {\n      let joinChar = \"?\";\n      if (path.indexOf(joinChar) !== -1) {\n        joinChar = \"&\";\n      }\n      path = path + joinChar + querystring.stringify(qs);\n    }\n\n    const file = options.file;\n    delete options.file; // We don't send this as metadata\n\n    const formData = {};\n\n    if (file) {\n      formData[\"filedata\"] = {\n        value: file,\n        options: {\n          filename: options.filename || null,\n        },\n      };\n    }\n\n    if (options.info) {\n      formData.info = JSON.stringify(options.info);\n    }\n\n    if (options.url) {\n      formData.url = options.url;\n    }\n\n    let protocol = this.port === 443 ? \"https://\" : \"http://\";\n\n    this.requestLib.post(\n      {\n        url: protocol + this.host + path,\n        formData: formData,\n        headers: {\n          Authorization: `Bearer ${this.credentials.generateJwt()}`,\n        },\n      },\n      callback\n    );\n  }\n\n  post(path, params, callback, useJwt) {\n    let qs = {};\n    if (!useJwt) {\n      qs[\"api_key\"] = this.credentials.apiKey;\n      qs[\"api_secret\"] = this.credentials.apiSecret;\n    }\n\n    let joinChar = \"?\";\n    if (path.indexOf(joinChar) !== -1) {\n      joinChar = \"&\";\n    }\n\n    path = path + joinChar + querystring.stringify(qs);\n\n    this.request(\n      {\n        path: path,\n        body: querystring.stringify(params),\n      },\n      \"POST\",\n      callback\n    );\n  }\n\n  postJson(path, params, callback, useJwt, useBasicAuth) {\n    let qs = {};\n    if (!useJwt && !useBasicAuth) {\n      qs[\"api_key\"] = this.credentials.apiKey;\n      qs[\"api_secret\"] = this.credentials.apiSecret;\n    }\n\n    let joinChar = \"?\";\n    if (path.indexOf(joinChar) !== -1) {\n      joinChar = \"&\";\n    }\n\n    path = path + joinChar + querystring.stringify(qs);\n\n    let headers = {\n      \"Content-Type\": \"application/json\",\n    };\n    if (useBasicAuth) {\n      headers[\"Authorization\"] = `Basic ${Buffer.from(\n        this.credentials.apiKey + \":\" + this.credentials.apiSecret\n      ).toString(\"base64\")}`;\n    }\n\n    this.request(\n      {\n        path: path,\n        body: JSON.stringify(params),\n        headers,\n      },\n      \"POST\",\n      callback\n    );\n  }\n\n  postUseQueryString(path, params, callback, useJwt) {\n    params = params || {};\n    if (!useJwt) {\n      params[\"api_key\"] = this.credentials.apiKey;\n      params[\"api_secret\"] = this.credentials.apiSecret;\n    }\n\n    path = path + \"?\" + querystring.stringify(params);\n    this.request(\n      {\n        path: path,\n      },\n      \"POST\",\n      callback\n    );\n  }\n}\n\nexport default HttpClient;\n"]},"metadata":{},"sourceType":"script"}